"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[565],{5675:(e,o,t)=>{t.r(o),t.d(o,{assets:()=>i,contentTitle:()=>s,default:()=>p,frontMatter:()=>l,metadata:()=>a,toc:()=>c});var n=t(5893),r=t(1151);const l={},s="Vovk Client",a={id:"getting-started/client",title:"Vovk Client",description:"vovk/client module exports utilities that turn controllers in a well-typed TypeScript library. It recognises types imported with import type from controllers.",source:"@site/docs/getting-started/client.md",sourceDirName:"getting-started",slug:"/getting-started/client",permalink:"/docs/getting-started/client",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/getting-started/client.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Translate your site",permalink:"/docs/tutorial-extras/translate-your-site"},next:{title:"Custom Decorators",permalink:"/docs/getting-started/decorators"}},i={},c=[{value:"Overriding default fetch function",id:"overriding-default-fetch-function",level:2},{value:"Automatically generated endpoints",id:"automatically-generated-endpoints",level:2},{value:"Error handling",id:"error-handling",level:2},{value:"Type extraction",id:"type-extraction",level:2}];function d(e){const o={code:"code",em:"em",h1:"h1",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,r.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(o.h1,{id:"vovk-client",children:"Vovk Client"}),"\n",(0,n.jsxs)(o.p,{children:[(0,n.jsx)(o.strong,{children:"vovk/client"})," module exports utilities that turn controllers in a well-typed TypeScript library. It recognises types imported with ",(0,n.jsx)(o.code,{children:"import type"})," from controllers."]}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"// vovk/hello/HelloController.ts - the back-end\nimport { post, type VovkRequest } from 'vovk';\n\nexport class HelloController {\n    static controllerName = 'HelloController';\n\n    @post('hello/:someParam')\n    static postSomeData(req: VovkRequest<{ hello: number }, { foo: string }>, { someParam }: { someParam: string }) {\n        const body = await req.json(); // casted as { hello: number }\n        const foo = req.nextUrl.get('foo'); // casted as string\n        const bar = req.nextUrl.get('bar'); // casted as never\n\n        return {\n            hello: body.hello,\n            foo,\n            someParam,\n        }\n    }\n}\n"})}),"\n",(0,n.jsxs)(o.p,{children:[(0,n.jsx)(o.code,{children:"clientizeController"})," accepts controller types and controller metadata as an input and returns fetching library. The fetching library consists all controller methods as well as type recognition for body, query, params and return type. It's worthy to mention that Proxy object isn't used here."]}),"\n",(0,n.jsx)(o.p,{children:"Vovk supports any application state library. At this example I'm going to use a simple object."}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"// vovk/hello/HelloState.ts - the front-end\nimport { clientizeController } from 'vovk/client';\nimport type HelloController from './HelloController';\nimport metadata from '../vovk-metadata.json' assert { type: 'json' };\n\ntype HelloControllerType = typeof HelloController;\n\nconst controller = clientizeController<HelloControllerType>(metadata.HelloController);\n\nconst helloState = {\n    postSomeData: async (hello: string, foo: string) => {\n        /* controller.postSomeData is casted as \n          ({\n            body: { hello: number },\n            query: { foo: string },\n            params: { someParam: string }\n          }) => Promise<{ hello: number; foo: string; someParam: string }>\n        */\n        const result = await controller.postSomeData({\n            body: { hello: 42 },\n            query: { foo: 'baz' },\n            params: { someParam: 'param' }\n        });\n\n        // result is casted as { hello: string; foo: string; someParam: string }\n        return result;\n    }\n}\n"})}),"\n",(0,n.jsxs)(o.p,{children:[(0,n.jsx)(o.code,{children:"VovkRequest"})," also supports branded and flavoured types."]}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"// vovk/hello/HelloController.ts\nexport type Hello = number & { __type: 'hello' };\nexport type Foo = string & { __type: 'foo' };\n\nexport class HelloController {\n    // ...\n    static postSomeData(req: VovkRequest<{ hello: Hello }, { foo: Foo }> // ...\n    // ...\n"})}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"import type { default as HelloController, Hello, Foo } from './HelloController';\n\n// ...\n    /* controller.postSomeData is casted as \n        ({\n            body: { hello: Hello },\n            query: { foo: Foo },\n            params: { someParam: string }\n        }) => { hello: Hello; foo: Foo; someParam: string }\n    */\n    const result = await controller.postSomeData({\n        body: { hello: 42 as Hello },\n        query: { foo: 'baz' as Foo },\n        params: { someParam: 'param' }\n    });\n// ...\n"})}),"\n",(0,n.jsx)(o.h2,{id:"overriding-default-fetch-function",children:"Overriding default fetch function"}),"\n",(0,n.jsxs)(o.p,{children:["Almost every complex React project requires its own fetching implementation to interact with application state, show success and error messages, log errors to a third-party service such as Sentry. ",(0,n.jsx)(o.code,{children:"clientizeController"})," provides a set of options, and one of them is ",(0,n.jsx)(o.code,{children:"fetcher"})," that overrides the default fetcher that's provided out of the box."]}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"// vovk/hello/HelloState.ts\nimport { myCustomFetcher } from '../lib/client';\nimport type HelloController from './HelloController';\nimport metadata from '../vovk-metadata.json' assert { type: 'json' };\n\ntype HelloControllerType = typeof HelloController;\n\nconst controller = clientizeController<HelloControllerType>(metadata.HelloController, {\n    fetcher: myCustomFetcher,\n});\n"})}),"\n",(0,n.jsxs)(o.p,{children:["The fetcher implements type ",(0,n.jsx)(o.code,{children:"VovkClientFetcher<ApiOptions>"})," imported from ",(0,n.jsx)(o.strong,{children:"vovk/client"})," where ",(0,n.jsx)(o.code,{children:"ApiOptions"})," generic indicates custom options that you may find useful to implement at the client-side library."]}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"// lib/client\ntype ApiOptions = {\n    successMesage: string;\n};\n\nconst myCustomFetcher: VovkClientFetcher<ApiOptions> = (\n  { httpMethod, getPath, validate },\n  { params, query, body, ...options }\n) => {\n  const { successMessage } = options;\n  const endpoint = getPath(params, query);\n\n  try {\n    validate({ body, query });\n  } catch {\n    alert('Validation eror');\n  }\n\n  try {\n    const resp = await fetch(endpoint, {\n      method: httpMethod,\n      body: JSON.stringify(body)\n    });\n\n    const json = await resp.json();\n\n    alert(successMessage);\n\n    return json;\n  } catch {\n    alert('Unable to fetch or parse the response')\n  }\n};\n\n"})}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"// vovk/hello/HelloState.ts\nimport { myCustomFetcher } from '../lib/client';\n// ... rest imports\n\nconst controller = clientizeController<HelloControllerType>(metadata.HelloController, {\n    fetcher: myCustomFetcher,\n});\n"})}),"\n",(0,n.jsx)(o.p,{children:"You can also export your own clientize function to avoid repeating yourself."}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"// lib/client\n\ntype ApiOptions = // ...\n\nconst myCustomFetcher = // ...\n\nexport const clientize = <T>(controllerMetadata: Parameters<typeof clientizeController>[0]) => {\n  return clientizeController<T, ApiOptions>(controllerMetadata, {\n    fetcher: clientFetcher,\n  });\n};\n"})}),"\n",(0,n.jsx)(o.p,{children:"Then import it to your state file:"}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"// vovk/hello/HelloState.ts\nimport { clientize } from '../lib/client';\nimport type HelloController from './HelloController';\n\ntype HelloControllerType = typeof HelloController;\n\nconst controller = clientize<HelloControllerType>(metadata.HelloController);\n\n// ...\n"})}),"\n",(0,n.jsx)(o.h2,{id:"automatically-generated-endpoints",children:"Automatically generated endpoints"}),"\n",(0,n.jsxs)(o.p,{children:["If the API (or part of it) of the Vovk app isn't going to be exposed for remote use, you can avoid endpoint definition completely. All HTTP decorators have ",(0,n.jsx)(o.code,{children:".auto()"})," method that generates endpoint name automatically from controller name and static method name."]}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"// vovk/hello/HelloController.ts - the back-end\nimport { get, type VovkRequest } from 'vovk';\n\nexport class HelloController {\n    static controllerName = 'HelloController';\n\n    @get.auto()\n    static postSomeData(req: VovkRequest) {\n        // ...\n    }\n}\n"})}),"\n",(0,n.jsxs)(o.p,{children:["The above example is going to create GET endpoint with path ",(0,n.jsx)(o.em,{children:"hello-controller/post-some-data"}),". If ",(0,n.jsx)(o.code,{children:"@prefix"})," is used, the endpoint path is going to be concatenated with it."]}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"// vovk/hello/HelloController.ts - the back-end\nimport { get, prefix, type VovkRequest } from 'vovk';\n\n@prefix('foo')\nexport class HelloController {\n    static controllerName = 'HelloController';\n\n    @get.auto()\n    static postSomeData(req: VovkRequest) {\n        // ...\n    }\n}\n"})}),"\n",(0,n.jsxs)(o.p,{children:["The example above creates GET endpoint with path ",(0,n.jsx)(o.em,{children:"foo/hello-controller/post-some-data"}),". Endpoint obfuscation is prioritised at the project roadmap."]}),"\n",(0,n.jsx)(o.h2,{id:"error-handling",children:"Error handling"}),"\n",(0,n.jsxs)(o.p,{children:["Errors thrown by controller are re-thrown at client-side. The error object implements ",(0,n.jsx)(o.code,{children:"ErrorResponseBody"})," type that looks like that:"]}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"// internal Vovk type\nexport type ErrorResponseBody = {\n  statusCode: HttpStatus;\n  message: string;\n  isError: true;\n}\n"})}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"// vovk/hello/HelloController.ts\nimport { get, type VovkRequest } from 'vovk';\n\nexport class HelloController {\n    static controllerName = 'HelloController';\n\n    @get(':someParam')\n    static doSomething(req: VovkRequest) {\n        // ...\n        throw new Error('Some error');\n        // ...\n    }\n}\n"})}),"\n",(0,n.jsx)(o.p,{children:"There is how you handle the errors on the client-side:"}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"// vovk/hello/HelloState.ts\nimport type { ErrorResponseBody } from 'vovk';\n\n// ...\nexport const helloState = {\n    doSomething: () => {\n        try {\n            await controller.doSomething({ body, query, params });\n        } catch (e) {\n            const err = e as ErrorResponseBody;\n\n            console.log(err); // { message: 'Some error', statusCode: 500, isError: true }\n        }\n    }\n};\n"})}),"\n",(0,n.jsxs)(o.p,{children:["Regular errors are treated as 500 errors. To throw specific error codes at the controller you can throw an instance of ",(0,n.jsx)(o.code,{children:"HttpException"})," that receives ",(0,n.jsx)(o.code,{children:"HttpStatus"})," enum value as the first argument and error message as the second."]}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"// vovk/hello/HelloController.ts\nimport { get, HttpStatus, HttpException } from 'vovk';\n\nexport class HelloController {\n    static controllerName = 'HelloController';\n\n    @get(':someParam')\n    static doSomething() {\n        // ...\n        throw new HttpException(HttpStatus.BAD_REQUEST, 'Some error');\n        // ...\n    }\n}\n"})}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"// vovk/hello/HelloState.ts\n// ...\ntry {\n    await controller.doSomething({ body, query, params });\n} catch (e) {\n    const err = e as ErrorResponseBody;\n\n    console.log(err); // { message: 'Some error', statusCode: 400, isError: true }\n}\n// ...\n"})}),"\n",(0,n.jsx)(o.h2,{id:"type-extraction",children:"Type extraction"}),"\n",(0,n.jsx)(o.p,{children:"Vovk.ts provides some useful types that allow you to extract type from the controller methods."}),"\n",(0,n.jsx)(o.p,{children:"Let's say you have the following controller:"}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"// vovk/hello/HelloController.ts - the back-end\nimport { get, type VovkRequest } from 'vovk';\n\nexport class HelloController {\n    static controllerName = 'HelloController';\n\n    @get(':someParam')\n    static doSomething(req: VovkRequest<{ body: true }, { query: string }>, { someParam }: { someParam: string }) {\n        // ...\n        return { success: true };\n    }\n}\n"})}),"\n",(0,n.jsxs)(o.p,{children:["You can extract types of ",(0,n.jsx)(o.code,{children:"doSomething"})," defined with ",(0,n.jsx)(o.code,{children:"VovkRequest"})," the wollowing way:"]}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"// vovk/hello/HelloState.ts\nimport type { VovkBody, VovkQuery, VovkParams, VovkReturnType } from 'vovk';\nimport type HelloController from './HelloController';\n\ntype HelloControllerType = typeof HelloController;\n\n// { body: true }\ntype DoSomethingBody = VovkBody<HelloControllerType['doSomething']>;\n// { query: string }\ntype DoSomethingQuery = VovkQuery<HelloControllerType['doSomething']>;\n// { someParam: string }\ntype DoSomethingParams = VovkParams<HelloControllerType['doSomething']>;\n// { success: boolean }\ntype DoSomethingReturnType = VovkReturnType<HelloControllerType['doSomething']>;\n"})}),"\n",(0,n.jsx)(o.p,{children:"And you can use these types to define client-side methods that invoke clientized controller methods."}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"// vovk/hello/HelloState.ts\nimport type { VovkBody, VovkQuery, VovkParams, VovkReturnType } from 'vovk';\nimport type HelloController from './HelloController';\n\n// const controller = clientizeController ...\n\nexport const helloState = {\n    doSomething: (\n        body: VovkBody<HelloControllerType['doSomething']>, \n        query: VovkQuery<HelloControllerType['doSomething']>, \n        params: VovkParams<HelloControllerType['doSomething']>\n    ): Promise<VovkReturnType<HelloControllerType['doSomething']>> => {\n        return controller.doSomething({ body, query, params });\n    }\n};\n"})})]})}function p(e={}){const{wrapper:o}={...(0,r.a)(),...e.components};return o?(0,n.jsx)(o,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},1151:(e,o,t)=>{t.d(o,{Z:()=>a,a:()=>s});var n=t(7294);const r={},l=n.createContext(r);function s(e){const o=n.useContext(l);return n.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function a(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),n.createElement(l.Provider,{value:o},e.children)}}}]);