"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8735],{3649:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var o=t(5893),s=t(1151);const r={},a="Streaming",l={id:"getting-started/streaming",title:"Streaming",description:"Besides regular HTTP requests Vovk.ts supports event streaming that especially useful with the modern AI APIs. To implement response streming the API route function can return",source:"@site/docs/getting-started/streaming.md",sourceDirName:"getting-started",slug:"/getting-started/streaming",permalink:"/docs/getting-started/streaming",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/getting-started/streaming.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Sponsor",permalink:"/docs/getting-started/sponsor"},next:{title:"Request validation",permalink:"/docs/getting-started/validation"}},i={},c=[{value:"Handling stream responses on client",id:"handling-stream-responses-on-client",level:2},{value:"Error handling",id:"error-handling",level:2},{value:"Overriding the default stream fetcher",id:"overriding-the-default-stream-fetcher",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,s.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{id:"streaming",children:"Streaming"}),"\n",(0,o.jsxs)(n.p,{children:["Besides regular HTTP requests ",(0,o.jsx)(n.strong,{children:"Vovk.ts"})," supports event streaming that especially useful with the modern AI APIs. To implement response streming the API route function can return"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"// vovk/hello/StreamingController.ts\nimport { StreamResponse, type VovkRequest } from 'vovk';\nimport HelloService, { type Token } from './HelloService';\n\nexport default class HelloController {\n  static controllerName = 'StreamingController';\n\n  private static helloService = HelloService;\n\n  @post.auto()\n  static async streamTokens(req: VovkRequest<{ hello: string }>) {\n    const body = await req.json(); // handle body if needed\n    const response = new StreamResponse<Token>();\n\n    void this.helloService.streamTokens(response);\n\n    return response;\n  }\n"})}),"\n",(0,o.jsxs)(n.p,{children:["At this example ",(0,o.jsx)(n.code,{children:"HelloService"})," provides ",(0,o.jsx)(n.code,{children:"streamTokens"})," function that accepts the response object and simulates token streaming every 300 second. The API endpoint returns an instance of ",(0,o.jsx)(n.code,{children:"StreamResponse<Token>"})," where ",(0,o.jsx)(n.code,{children:"Token"})," type is going to be recognised by the front-end. Under the hood ",(0,o.jsx)(n.code,{children:"StreamResponse"})," is just ",(0,o.jsx)(n.code,{children:"Response"})," instance that accepts ",(0,o.jsx)(n.code,{children:"TransformStream['readable']"})," as body and runs certain workarounds to avoid data collisions."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"// vovk/hello/HelloService.ts\nexport type Token = { message: string };\n\nexport default class HelloService {\n  static async streamTokens(response: StreamResponse<Token>) {\n    const tokens = [{ message: 'Hello,' }, { message: ' World' }, { message: '!' }];\n\n    for (const token of body) {\n        await new Promise((resolve) => setTimeout(resolve, 300));\n        await response.send(token);\n    }\n\n    return response.close();\n  }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["As you can see ",(0,o.jsx)(n.code,{children:"StreamResponse"})," provides ",(0,o.jsx)(n.code,{children:"send"})," method that sends new portion of data to the client-side and ",(0,o.jsx)(n.code,{children:"close"})," method that stops streaming and safely closes the stream."]}),"\n",(0,o.jsx)(n.h2,{id:"handling-stream-responses-on-client",children:"Handling stream responses on client"}),"\n",(0,o.jsxs)(n.p,{children:["Client methods created using ",(0,o.jsx)(n.code,{children:"clientizeController"})," accepts ",(0,o.jsx)(n.code,{children:"isStreaming"})," option. This option makes the library call stream fetcher - the different implementation of fetcher that supports response streaming."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"// vovk/hello/HelloState.ts\nimport { clientizeController } from 'vovk/client';\nimport type HelloController from './HelloController';\nimport type { Token } from './HelloService';\nimport metadata from '../vovk-metadata.json' assert { type: 'json' };\n\ntype HelloControllerType = typeof HelloController;\n\nconst controller = clientizeController<HelloControllerType>(metadata.HelloController);\n\nconst helloState = {\n    streamTokens: async () => {\n        const resp = await controller.streamTokens({\n            body: { hello: 'world' },\n            isStream: true, // !\n        });\n\n        for await (const token of resp) {\n            console.log(token satisfies Token);\n        }\n    }\n}\n\nexport default helloState;\n"})}),"\n",(0,o.jsxs)(n.p,{children:["As you can see ",(0,o.jsx)(n.code,{children:"streamTokens"})," returns a promise thar resolves async iterable that yields messages of type ",(0,o.jsx)(n.code,{children:"Token"})," defined at ",(0,o.jsx)(n.code,{children:"HelloService"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"error-handling",children:"Error handling"}),"\n",(0,o.jsxs)(n.p,{children:["Streaming response can be safely interrupted by using ",(0,o.jsx)(n.code,{children:"throw"})," method that accepts an argument that re-throws the same error on client-side."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"// vovk/hello/HelloService.ts\n// ...\n\nexport default class HelloService {\n  static async streamTokens(response: StreamResponse<Token>) {\n    // ...\n    return response.throw({ hello: 'World' });\n    // ...\n  }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["You can wrap ",(0,o.jsx)(n.code,{children:"for await"})," loop by try..catch to catch the error thrown by using ",(0,o.jsx)(n.code,{children:"response.throw"})," method. At this example ",(0,o.jsx)(n.code,{children:"{ hello: 'World' }"})," object is going to be thrown."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"// vovk/hello/HelloState.ts\n// ...\n\nconst helloState = {\n    streamTokens: async () => {\n        const resp = await controller.streamTokens({\n            body: { hello: 'world' },\n            isStream: true,\n        });\n\n        try {\n            for await (const token of resp) {\n                console.log(token);\n            }\n        } catch(e) {\n            console.error(e); // { hello: 'world' }\n        }\n        \n    }\n}\n\nexport default helloState;\n"})}),"\n",(0,o.jsxs)(n.p,{children:["On the back-end you can also wrap the streaming code by try..catch and re-throw it on the client by using ",(0,o.jsx)(n.code,{children:"response.throw"})," method."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"// vovk/hello/HelloService.ts\nimport OpenAI from 'openai';\n// ...\nconst openai = new OpenAI();\n\nexport default class HelloService {\n  static async streamTokens(response: StreamResponse<OpenAI.Chat.Completions.ChatCompletionChunk>) {\n    const stream = await openai.chat.completions.create({\n        model: 'gpt-4',\n        messages: [{ role: 'user', content: 'Say this is a test' }],\n        stream: true,\n    });\n\n    try {\n        for await (const part of stream) {\n            await response.send(part.choices[0]?.delta?.content || '');\n        }\n    } catch (e) {\n        return response.throw({ openAiError: String(e) });\n    }\n\n    return response.close();\n  }\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"overriding-the-default-stream-fetcher",children:"Overriding the default stream fetcher"}),"\n",(0,o.jsxs)(n.p,{children:["You can override front-end function that is used internally when ",(0,o.jsx)(n.code,{children:"isStream: true"})," is provided. To do that pass ",(0,o.jsx)(n.code,{children:"streamFetcher"})," option to ",(0,o.jsx)(n.code,{children:"clientizeController"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import { myCustomStreamFetcher } from '../lib/client';\n\nconst controller = clientizeController<HelloControllerType>(metadata.HelloController, {\n    streamFetcher: myCustomStreamFetcher,\n});\n\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"defaultStreamFetcher"})," that is used internally if ",(0,o.jsx)(n.code,{children:"streamFetcher"})," isn't provided is too complex to explain it at this documentation. Please check project source code if you need to re-define ",(0,o.jsx)(n.code,{children:"streamFetcher"})," option."]})]})}function h(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>l,a:()=>a});var o=t(7294);const s={},r=o.createContext(s);function a(e){const n=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);