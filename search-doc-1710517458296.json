{"searchDocs":[{"title":"MDX Blog Post","type":0,"sectionRef":"#","url":"/blog/mdx-blog-post","content":"Blog posts support Docusaurus Markdown features, such as MDX. tip Use the power of React to create interactive blog posts. &lt;button onClick={() =&gt; alert('button clicked!')}&gt;Click me!&lt;/button&gt; Click me!","keywords":"","version":null},{"title":"First Blog Post","type":0,"sectionRef":"#","url":"/blog/first-blog-post","content":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet","keywords":"","version":null},{"title":"Long Blog Post","type":0,"sectionRef":"#","url":"/blog/long-blog-post","content":"This is the summary of a very long blog post, Use a &lt;!-- truncate --&gt; comment to limit blog post size in the list view. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet","keywords":"","version":null},{"title":"Welcome","type":0,"sectionRef":"#","url":"/blog/welcome","content":"Docusaurus blogging features are powered by the blog plugin. Simply add Markdown files (or folders) to the blog directory. Regular blog authors can be added to authors.yml. The blog post date can be extracted from filenames, such as: 2019-05-30-welcome.md2019-05-30-welcome/index.md A blog post folder can be convenient to co-locate blog post images: The blog supports tags as well! And if you don't want a blog: just delete this directory, and use blog: false in your Docusaurus config.","keywords":"","version":null},{"title":"About","type":0,"sectionRef":"#","url":"/docs/about","content":"","keywords":"","version":"Next"},{"title":"Motivation‚Äã","type":1,"pageTitle":"About","url":"/docs/about#motivation","content":" Next.js de facto became a standard framework for front-end React applications that includes SSR, HMR, ready-to-go router, bunch of loaders and many more other features out of the box. Unfortunately, to implement back-end capabilities a developer needs to use insufficient built-in API router that requires to create a lot of folders with route.ts file or use workarounds that implement custom protocols instead of using the well-known REST API. Vovk.ts attempts to fix this problem by implementing a wrapper over Next.js Optional Catch-all Segment and automatically compiles a client-side TypeScript library that can be imported from vovk-client module. As a reference it uses auto-generated metadata file .vovk.json file from the root of the project that needs to be committed to re-generate the client library on deployment or when node_modules are reinstalled with npx vovk generate.  Vovk.ts uses standard APIs such as Fetch API and Response object to implement its features. It provides an easy to use library utilising built-in browser and Next.js APIs that you would use anyway with Next.js route.ts (including redirect, headers, notFound, req.formData etc). If you're new to Next.js I recommend to check Next.js App Router documentation first.  The project originally inspired by NestJS that is probably the best framework on the market for scaleable and complex back-end. The first step in Vovk.ts development (that wasn't even considered to be an open-sourced project back then) was an attempt to merge Next.js and NestJS thru Next.js middleware. This attempt wasn't successful and the decision was to build similar project from scratch using the Optional Catch-all Segment utilising the most important features of NestJS: classes, decorators and the service-controller pattern. At the same time the Angular-like features such as dependency injection and the way to define modules looked redundant since they weren't useful in practice (even the best tools can be simpler).  The library also provides Web Worker interface utilising the same approach with the metadata file to generate main-thread library for heavy in-browser calculations to avoid glitches in the UI when it's applicable. Web Worker is a fantastic technology but it's not used widely because it requires a lot of effort to organise event listeners and postMessage calls. Vovk.ts attemtps to popularise this technology to make complex front-end applications to perform faster by moving part of the application logic to another thread where low-performant code is inavoidable.  ","version":"Next","tagName":"h2"},{"title":"Features‚Äã","type":1,"pageTitle":"About","url":"/docs/about#features","content":" üëµ Good old REST API with no custom protocols.üö¢ Run full-stack Next.js application on one port avoiding monorepo hell.üßê Service-Controller-Repository pattern for the highest code quality.üöÑ Edge runtime is available out of the box.üåø Zero dependencies and light weight.ü§è Generated client code is compact, it's just a wrapper over fetch function.üì¶ Bundle and distribute production-ready client API library with Webpack, Rollup or another bundler.ü§ù Use standard Next.js API such as Response, headers or redirect, nothing is changed.üß† Easy to learn, only a few pages of documentation.üì± Easily integrated with React Native.ü§ñ Streaming for LLM apps with disposable async generators.üìÑ Static API generation with generateStaticAPI‚öôÔ∏è Web Worker interface for multi-threading in browser.üèéÔ∏è Fast on client and on server.üîß Customizable.ü•∞ TypeScript, TypeScript, TypeScript! ","version":"Next","tagName":"h2"},{"title":"How it Works","type":0,"sectionRef":"#","url":"/docs/how-it-works","content":"How it Works vovk dev finds the closest available port to run Next.js server by itself. This is an important step that allows Vovk Metadata Server to know the process.env.PORT and Next.js dev server to know process.env.VOVK_PORT. If VOVK_PORT is not set the library going to add a magic number to PORT value. This is the only purpose of this wrapper around the standard next dev command.When available port is found Vovk runs two processes (similar to concurrently) in parallel: Vovk Metadata Server and the regular next dev.Each time when an endpoint is requested in dev mode, initVovk is initialised again and it POSTs information about controllers and workers to the Vovk Metadata Server. Previous major version of Vovk.ts used fs Node.js module to write metadata file but this approach didn't work in Edge Runtime since most of the standard Node.js capabilities can't be used this environment. Instead of fs Vovk.ts starts its own server that accepts the required via POST request made by initVovk function. In production initVovk is called once for each instance of the application to initialise controllers and doesn't perform actions described on this page.The Metadata Server accepts this data and if a change is detected it updates .vovk.json and node_modules/.vovk (it contains the generated client) automatically. By Next.js design endpoints handled by Optional Catch-all Segment execute its code each time when the endpoint is requested.To make development process seamless and to trigger file creation without calling any endpoint manually, Vovk Metadata Server constrantly pings GET /api/__ping every 3 seconds to make the client regenerated automatically.If metadata is changed, the Metadata Server regenerates .vovk.json and files ay node_modules/.vovk that contains .js and .d.ts files for the client. Vovk.ts doesn't watch files and doesn't use AST to build the client making client generating to perform instantly considering the short ping delay.","keywords":"","version":"Next"},{"title":"CLI","type":0,"sectionRef":"#","url":"/docs/cli","content":"","keywords":"","version":"Next"},{"title":"vovk dev‚Äã","type":1,"pageTitle":"CLI","url":"/docs/cli#vovk-dev","content":" Runs Vovk Metadata Server and next dev in parallel. Next.js dev server will send information about controllers and worker services to the Metadata Server to build .vovk.json and node_modules/.vovk files. Please check How it Works for more info.  vovk dev supports --no-next-dev flag that indicates that it shouldn't run next dev. This is useful in case if you want to take control over next dev and run it by yourself with concurrently or similar library. At this case it is required to set PORT env variable explicitly.  PORT=4000 concurrently 'vovk dev --no-next-dev' 'next dev' --kill-others   To devine Vovk Metadata Server port you can use VOVK_PORT variable.  For vovk dev all flags that come after -- are passed directly to next dev as is, if --no-next-dev is not given.  npx vovk dev --clientOut=my-custom-folder -- --experimental-https --keepAliveTimeout 70000   ","version":"Next","tagName":"h2"},{"title":"vovk generate‚Äã","type":1,"pageTitle":"CLI","url":"/docs/cli#vovk-generate","content":" Generates the client based on .vovk.json and creates .js and .d.ts files at node_modules/.vovk that are re-exported by vovk-client. .vovk.json is generated via vovk dev.  Both commands accept --clientOut flag that indicates where client needs to be generated.  npx vovk generate --clientOut=my-custom-folder   All other commands such as next build and next start remain the same since the project is a normal Next.js application.  ","version":"Next","tagName":"h2"},{"title":"Available env variables‚Äã","type":1,"pageTitle":"CLI","url":"/docs/cli#available-env-variables","content":" Environment variables allow to customize Vovk.ts behaviour by overriding configuration optionally defined at vovk.config.js. You can find more information about it at Customization &amp; Configuration page of this documentation. Here is a quick ref:  PORT=3000 - defines port for Next.js server that is also used by the Metadata Server to ping Next.js server (relevant for vovk dev only).VOVK_PORT=3690 - An optional Vovk Metadata Server port (relevant for vovk dev only).VOVK_CLIENT_OUT=./node_modules/.vovk - where the client needs to be compiled to.VOVK_ROUTE=./src/app/api/[[...vovk]]/route.ts - allows to redefine path to the wildcard route.VOVK_FETCHER=vovk/client/defaultFetcher - allows to customize the fetching function that used internally by the client.VOVK_PREFIX=/api - defines the root endpoint used by fetch function at the client.VOVK_VALIDATE_ON_CLIENT - defines client-side validation library. If vovk-zod is installed but VOVK_VALIDATE_ON_CLIENT is not redefined it's value going to be defined as vovk-zod/zodValidateOnClient. ","version":"Next","tagName":"h2"},{"title":"Roadmap & Changelog","type":0,"sectionRef":"#","url":"/docs/roadmap","content":"","keywords":"","version":"Next"},{"title":"Roadmap‚Äã","type":1,"pageTitle":"Roadmap & Changelog","url":"/docs/roadmap#roadmap","content":" Support OpenAPI.An option to obfuscate endpoint names when .auto() decorators are used.Support Transferable objects at workers.(Experimental) Add support of AssemblyScript.(Experimental) Implement shared object that is read by all workers and the main thread using Atomics and SharedArrayBuffer.  ","version":"Next","tagName":"h2"},{"title":"Changelog‚Äã","type":1,"pageTitle":"Roadmap & Changelog","url":"/docs/roadmap#changelog","content":" ","version":"Next","tagName":"h2"},{"title":"v1.1.0‚Äã","type":1,"pageTitle":"Roadmap & Changelog","url":"/docs/roadmap#v110","content":" ‚úÖ Support .js, .cjs, .mjs extensions for Vovk Config‚úÖ Rebuild client automatically once Vovk Config is changed without restarting the server  ","version":"Next","tagName":"h3"},{"title":"v1.0.0‚Äã","type":1,"pageTitle":"Roadmap & Changelog","url":"/docs/roadmap#v100","content":" ‚úÖ Generate client library automatically.‚úÖ Support Edge Runtime.‚úÖ Export StreamResponse class to use as a response pointer in Services and to implement streaming without generators syntax.‚úÖ Extract generator types.‚úÖ Implement disposable objects (using keyword) to close stream responses automatically. ","version":"Next","tagName":"h3"},{"title":"Sponsor","type":0,"sectionRef":"#","url":"/docs/sponsor","content":"Sponsor Sponsor the author of the project on Github ‚ô•Ô∏è You can also contact me via email from my Github profile. I hope you enjoy Vovk!","keywords":"","version":"Next"},{"title":"Customization & Configuration","type":0,"sectionRef":"#","url":"/docs/customization","content":"","keywords":"","version":"Next"},{"title":"vovk.config.js‚Äã","type":1,"pageTitle":"Customization & Configuration","url":"/docs/customization#vovkconfigjs","content":" The config file allows to change default options in order to customise generated client or its path. The default config looks like that:  /** @type {import('vovk').VovkConfig} */ const vovkConfig = { clientOut: './node_modules/.vovk', route: './src/app/api/[[...vovk]]/route.ts', fetcher: 'vovk/client/defaultFetcher', prefix: '/api', validateOnClient: '', }; module.exports = vovkConfig;   clientOut - where the client is going to be compiled to. Can be overriden by VOVK_CLIENT_OUT env variable.route - allows to redefine path to the wildcard route (the slug can be any non-empty string, it's name is not utilised by Vovk.ts). Can be overriden by VOVK_ROUTE env variable.fetcher - allows to customize the fetching function that used internally by the client. Can be overriden by VOVK_FETCHER env variable. See the next section for more info.prefix - defines the root endpoint used by fetch function at the client. Can be overriden by VOVK_PREFIX env variable.validateOnClient - defines client-side validation library. If vovk-zod is installed but validateOnClient is not redefined it's value going to get value vovk-zod/zodValidateOnClient. Can be overriden by VOVK_VALIDATE_ON_CLIENT env variable.  The config can be also defined as vovk.config.cjs but also as an ES Module named vovk.config.mjs:  /** @type {import('vovk').VovkConfig} */ const vovkConfig = { // ... }; export default vovkConfig;   ","version":"Next","tagName":"h2"},{"title":"Customizing fetcher and default client options‚Äã","type":1,"pageTitle":"Customization & Configuration","url":"/docs/customization#customizing-fetcher-and-default-client-options","content":" You can redefine the default fetching function and its options to tightly integrate Vovk.ts client with your application state or to add extra features. For example, the clientized controller methods may look like that:  import { UserController } from 'vovk-client'; // ... UserController.createUser({ body, query, successToast: 'Successfully created a new user', useAuth: true, sentryLogErrors: true, });   The fetcher is defined as a default export that extends VovkClientFetcher type and should be listed either as config option:  /** @type {import('vovk').VovkConfig} */ const vovkConfig = { fetcher: './src/lib/myFetchingFunction', }; module.exports = vovkConfig;   Or as VOVK_FETCHER env variable:  VOVK_FETCHER=&quot;./src/lib/myFetchingFunction&quot; vovk dev   By default Vovk.ts uses fetcher defined at vovk/client/defaultFetcher and you can check its source code here.  The fetcher accepts two arguments:  An object that is provided by internal Vovk.ts code that includes HTTP method information and utilities: httpMethod - the HTTP metod;getEndpoint - an utility that builds request endpoiint from prefix, query and params;validate - a function that validates body and query of the request;defaultHandler - handles the Response object returned from fetch function;defaultStreamHandler - handles the Response object returned from fetch function in case of a stream. Request arguments: params - the patams such as id from users/:id;query - the search query properties such as ?foo=bar;body - the request body;prefix - what's defined as prefix property at vovk.config.js or passed directly to the client method;The rest options - your custom options and RequestInit (including custom Next.js options) that includes the rest fetch options such as headers, credentials etc.  Your custom fetcher with a custom option successMessage may look like that:  import type { VovkDefaultFetcherOptions, VovkClientFetcher } from 'vovk'; // in order to keep default features such as disableClientValidation, headers etc, // it's recommended to extend custom options from VovkDefaultFetcherOptions interface MyOptions extends VovkDefaultFetcherOptions { successMessage: string; } const myCustomFetcher: VovkClientFetcher&lt;MyOptions&gt; = async ( { httpMethod, getEndpoint, validate, defaultHandler, defaultStreamHandler }, { params, query, body, prefix = '/api', successMessage, ...options } ) =&gt; { // 1. Build the endpoint const endpoint = getEndpoint({ prefix, params, query }); // 2. Validate if (!options.disableClientValidation) { await validate({ body, query }); } // 3. Make fetch request (here you can add authorisation headers) const response = await fetch(endpoint, { method: httpMethod, body: JSON.stringify(body), ...options, }); // 4. Utilise your custom option somehow alert(successMessage); // 5. Handle response based on response headers if (response.headers.get('content-type')?.includes('application/json')) { return defaultHandler(response); } if (response.headers.get('content-type')?.includes('text/event-stream')) { return defaultStreamHandler(response); } return response; }; export default myCustomFetcher;   As you can see the code determines response type by content-type header. You can freely redefine this logic to make the fetcher return something else.  if (response.headers.get('content-type')?.includes('application/json')) { return yourCustomHandler(response); }   In case if the server endpoint and yourCustomHandler return different values, you can redefine its type using client method generic.  import { MyController } from 'vovk-client'; // ... const result = MyController.myMethod&lt;{ foo: 'bar' }&gt;({ body, successMessage: 'Success!' })   The result variable from this example is going to receive { foo: 'bar' } type.  ","version":"Next","tagName":"h2"},{"title":"Creating a custom validation library‚Äã","type":1,"pageTitle":"Customization & Configuration","url":"/docs/customization#creating-a-custom-validation-library","content":" If you need to create your custom validation library, check decorators documentation. ","version":"Next","tagName":"h2"},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/docs/intro","content":"","keywords":"","version":"Next"},{"title":"Quick install‚Äã","type":1,"pageTitle":"Getting Started","url":"/docs/intro#quick-install","content":" Setup Vovk.ts with create-next-app.  npx create-next-app -e https://github.com/finom/vovk-hello-world   Inside the project folder run npm run dev and open http://localhost:3000.  ","version":"Next","tagName":"h2"},{"title":"Manual install‚Äã","type":1,"pageTitle":"Getting Started","url":"/docs/intro#manual-install","content":" ","version":"Next","tagName":"h2"},{"title":"1. Create Next.js project with App Router and install Vovk.ts‚Äã","type":1,"pageTitle":"Getting Started","url":"/docs/intro#1-create-nextjs-project-with-app-router-and-install-vovkts","content":" Follow this instruction to install Next.js. Use TypeScript, App Router and src/ directory.  npx create-next-app   Choices example:    At the newly created folder run:  npm i vovk vovk-client   or  yarn add vovk vovk-client   ","version":"Next","tagName":"h3"},{"title":"2. Enable decorators‚Äã","type":1,"pageTitle":"Getting Started","url":"/docs/intro#2-enable-decorators","content":" In your tsconfig.json set &quot;experimentalDecorators&quot; to true.  { &quot;compilerOptions&quot;: { &quot;experimentalDecorators&quot;: true, // ... } }   ","version":"Next","tagName":"h3"},{"title":"3. Set up Next.js wildcard route handler and export types read by the client library‚Äã","type":1,"pageTitle":"Getting Started","url":"/docs/intro#3-set-up-nextjs-wildcard-route-handler-and-export-types-read-by-the-client-library","content":" Create file /src/app/api/[[...vovk]]/route.ts where [[...vovk]] is a folder name insicating what Next.js documentation calls &quot;Optional Catch-all Segment&quot; that can be customized. This is the core entry point for all Vovk.ts routes.  // /src/app/api/[[...vovk]]/route.ts import { initVovk } from 'vovk'; export const runtime = 'edge'; const controllers = {}; const workers = {}; // export types used by the client export type Controllers = typeof controllers; export type Workers = typeof workers; export const { GET, POST, PUT, DELETE } = initVovk({ controllers, workers });   Enabling Edge Runtime is optional.  ","version":"Next","tagName":"h3"},{"title":"4. Create first controller and add it to the controller object‚Äã","type":1,"pageTitle":"Getting Started","url":"/docs/intro#4-create-first-controller-and-add-it-to-the-controller-object","content":" Create HelloController.ts at /src/modules/hello/ with same-named static class.  // /src/modules/hello/HelloController.ts import { get, prefix } from &quot;vovk&quot;; @prefix('hello') // prefix is optional export default class HelloController { @get('greeting') static getHello() { return { greeting: 'Hello world!' }; } }   And add this class at /src/app/api/[[...vovk]]/route.ts to the controllers object.  // /src/app/api/[[...vovk]]/route.ts import HelloController from '../../../modules/hello/HelloController'; // ... const controllers = { HelloController }; // ...   The code above creates GET endpoint to /api/hello/greeting. You can also use named export for the controller if needed.  ","version":"Next","tagName":"h3"},{"title":"Create a React component and run vovk dev‚Äã","type":1,"pageTitle":"Getting Started","url":"/docs/intro#create-a-react-component-and-run-vovk-dev","content":" Once you run npx vovk dev that replaces the original npx next dev you're going to notice the new file .vovk.json created in the root of your project. This file contains required information to build the client and it needs to be committed. It's going to be updated automatically when your project structure is changed. Open http://localhost:3000.  Alternatively, you can use concurrently to avoid using the wrapper. Use --no-next-dev in order to avoid running next dev internally and provide PORT variable explicitly: PORT=3000 concurrently 'vovk dev --no-next-dev' 'next dev' --kill-others.  Besides .vovk.json the command also generates client .js and .ts files inside node_modules/.vovk that are re-exported by vovk-client module to produce no errors if vovk-client is not installed. This approach is borrowed from Prisma ORM.  Now the client is generated you can safely import your client library from vovk-client.  'use client'; import { useState } from 'react'; import { HelloController } from 'vovk-client'; import type { VovkClientReturnType } from 'vovk'; export default function MyComponent() { const [serverResponse, setServerResponse] = useState&lt;VovkClientReturnType&lt;typeof HelloController.getHello&gt;&gt;(); return ( &lt;&gt; &lt;button onClick={async () =&gt; { const response = await HelloController.getHello(); setServerResponse(response); }} &gt; Get Greeting from Server &lt;/button&gt; &lt;div&gt;{serverResponse?.greeting}&lt;/div&gt; &lt;/&gt; ); }   Note that if you're using VSCode you're probably going to need to restart TS server each time when you add a new controller or worker service to your app because by the time being TS Server doesn't update types imported from node_modules automatically when they were changed. This is a well-known problem that bothers Prisma ORM developers for long time. In all other scenarios (when you add a new method, change body type, etc) you don't need to do that since TS server reads Controllers and Workers that you export from /src/app/api/[[...vovk]]/route.ts.  Next.js Server Components are also supported but require to define absolute URL (by default all requests are made to /api). Check the Server Component Example for more information.  Methods of the generated library have approximately the following signature:  interface Options extends Omit&lt;RequestInit, 'body' | 'method'&gt; { reactNative?: { textStreaming: boolean }; prefix?: string; disableClientValidation?: boolean; body: VovkClientBody&lt;typeof Controller.method&gt; params: VovkClientParams&lt;typeof Controller.method&gt; query: VovkClientQuery&lt;typeof Controller.method&gt; }   In other words it supports custom Next.js options (Because Next.js extends RequestInit global type) as well as React Native Fetch API.  await HelloController.hello({ body: { foo: 'bar' }, next: { revalidate: 3600 }, });   ","version":"Next","tagName":"h2"},{"title":"Build and deploy‚Äã","type":1,"pageTitle":"Getting Started","url":"/docs/intro#build-and-deploy","content":" Use the regular npx next build to build the project. If the client wasn't generated in node_modules/.vovk before, you going to get compilation errors if vovk-client was imported somewhere in the app. To re-generate client with existing .vovk.json without re-builing the project itself you need to run npx vovk generate that updates node_modules/.vovk folder on deployment or after you've reinstalled your node_modules.  To easily build the project on Vercel you can create &quot;vercel-build&quot; npm script at package.json that is going to generate client before build.  &quot;scripts&quot;: { &quot;vercel-build&quot;: &quot;vovk generate &amp;&amp; next build&quot; }   ","version":"Next","tagName":"h2"},{"title":"Examples‚Äã","type":1,"pageTitle":"Getting Started","url":"/docs/intro#examples","content":" You can check more examples here. ","version":"Next","tagName":"h2"},{"title":"Project Structure","type":0,"sectionRef":"#","url":"/docs/project-structure","content":"","keywords":"","version":"Next"},{"title":"Controller Class‚Äã","type":1,"pageTitle":"Project Structure","url":"/docs/project-structure#controller-class","content":" Controller Class is a static class that defines API endpoints. It can use Back-End Service Classes and Isomorphic Service Classes explained below.  // /src/modules/post/PostController.ts import { prefix, get } from 'vovk'; import PostService from './PostService'; @prefix('post') export default class PostController { private static postService = PostService; @get() static getPosts() { return this.postService.getPosts(); } }   Decorators created with createDecorator make possible to validate request, throw errors, redirect, or return something different to the client.  // /src/modules/post/PostController.ts import { prefix, get, type VovkRequest } from 'vovk'; import vovkZod from 'vovk-zod'; import { z } from 'zod'; import { authGuard } from '../../decorators'; import PostService from './PostService'; @prefix('post') export default class PostController { private static postService = PostService; @put(':postId') @authGuard() @vovkZod( z.object({ title: z.string() content: z.string(), }).strict(), z.object({ moderationType: z.string(), }).strict() ) static updatePost( req: VovkRequest&lt;{ title: string; content: string; }, { moderationType: 'nice' | 'strict' }&gt;, { postId }: { postId: string } ) { const { title, content } = req.json(); const moderationType = req.nextUrl.searchParams.get('moderationType'); return this.postService.updatePost(postId, title, content, moderationType); } }   Let's break down the example above that implements PUT endpoint that looks like that: /api/post/69?moderationType=nice.  authGuard is a custom decorator that may be created by you based on your authorisation environment.vovkZod that's imported from vovk-zod performs Zod validation of body and query both on server-side and client-side.VovkRequest generic partially re-defines NextRequest type and makes req.json as well as req.nextUrl.searchParams.get return proper types.this.postService.updatePost is invoked with properly-typed arguments after authorisation check, body and query validation.  ","version":"Next","tagName":"h2"},{"title":"Back-end Service Class‚Äã","type":1,"pageTitle":"Project Structure","url":"/docs/project-structure#back-end-service-class","content":" Back-end Service Class (or just &quot;Service&quot;) is a static class that implements third-party API calls or performs requests do the project database. By design Services don't validate incoming data and play the role of back-end library.  Services can be injected to controllers as well as to other services using private static prefix.  // /src/modules/comment/CommentService.ts import PostIsomorphicService from '../post/PostIsomorphicService'; import UserService from '../user/UserService'; export default class CommentService { private static postIsomorphicServiceService = PostIsomorphicService; private static userService = UserService; static getAllUserComments(userId: User['id']) { const user = await this.userService.getUserById(userId); // ... perform database request return // ... } }   ","version":"Next","tagName":"h2"},{"title":"Isomorphic Service Class‚Äã","type":1,"pageTitle":"Project Structure","url":"/docs/project-structure#isomorphic-service-class","content":" Isomorphic Service is very similar to a Back-end Service but can be used both by front-end (state, components, Worker Service Classes, hooks, other Isomorphic Service Classes, ...) and back-end (Back-End Services, Controllers, CLI scripts, ...). The only difference is that its methods need to be implemented as pure functions. It means that it shouldn't perform DB calls nor access application state but can use other Isomorphic Service Classes.  // /src/modules/comment/CommentIsomorphicService.ts import PostIsomorphicService from '../post/PostIsomorphicService'; export default class CommentIsomorphicService { private static postIsomorphicService = PostIsomorphicService; // a pure function static filterCommentsByPostId(comments: Comment[], posts: Post, postId: Post['id']) { // findPostById is also a pure function const post = this.postIsomorphicService.findPostById(posts, postId); if(post.isDeleted) return []; return comments.filter((comment) =&gt; comment.postId === postId); } // ... }   ","version":"Next","tagName":"h2"},{"title":"Worker Service Class‚Äã","type":1,"pageTitle":"Project Structure","url":"/docs/project-structure#worker-service-class","content":" Every Isomorphic Service Class can be turned into a Worker Service by applying @worker() decorator. The decorator defines required onmessage listeners if it's imported in a Web Worker environment. In other cases @worker() decorator does nothing and still can be used as an Isomorphic Service.  // /src/modules/hello/HelloWorkerService.ts import { worker } from 'vovk'; @worker() export default class HelloWorkerService { static performHeavyCalculations() { // ... } }   The compiled interface can be imported from vovk-client.  // /src/app/page.tsx import { HelloWorkerService } from 'vovk-client'; // ... const onClick = useCallback(async () =&gt; { HelloWorker.use(new Worker(new URL('../modules/hello/HelloWorkerService.ts', import.meta.url))); const result = await worker.performHeavyCalculations(); console.log('result', result); }, []);   Worker Service Clases can use other Worker Services Classes, Isomorphic Service Classes and Back-End Controllers imported from vovk-client. For more info check documentation of Worker Service Classes.  ","version":"Next","tagName":"h2"},{"title":"State‚Äã","type":1,"pageTitle":"Project Structure","url":"/docs/project-structure#state","content":" State file contains application state code that is going to be imported by React Components and other state files. It can use Isomorphic Services, Worker Services and Controllers imported from vovk-client. State can be implemented with any application state library: Recoil, Redux, Redux Toolkit, MobX, custom context, or anything else since the framework does not cover state management topic.  // /src/modules/post/PostState.ts import { PostController, PostWorkerService } from 'vovk-client'; // ... init app state for posts   ","version":"Next","tagName":"h2"},{"title":"Other ideas‚Äã","type":1,"pageTitle":"Project Structure","url":"/docs/project-structure#other-ideas","content":" The framework isn't limited by the elements described above and you may want to add more files into your module folder.  More Back-end Service Classes.More Isomorphic Service Classes.More Worker Service Classes.Tests.React Components that you want to categorise (modules/hello/components/MyComponent.tsx).Types (modules/hello/HelloTypes.ts).Anything else you can imagine. ","version":"Next","tagName":"h2"},{"title":"Worker Service Class","type":0,"sectionRef":"#","url":"/docs/worker","content":"","keywords":"","version":"Next"},{"title":"Worker termination‚Äã","type":1,"pageTitle":"Worker Service Class","url":"/docs/worker#worker-termination","content":" A worker can be terminated with built-in terminate method.  worker.terminate();   ","version":"Next","tagName":"h2"},{"title":"Async generators‚Äã","type":1,"pageTitle":"Worker Service Class","url":"/docs/worker#async-generators","content":" Worker Service supports generators and async generators to implement continious event streaming.  // /src/modules/hello/HelloWorker.ts import { worker } from 'vovk'; @worker() export default class HelloWorkerService { static *generator() { for (let i = 0; i &lt; 10; i++) { yield i; } } static async *asyncGenerator() { for (let i = 0; i &lt; 10; i++) { await new Promise((resolve) =&gt; setTimeout(resolve, 100)); yield i; } } }   Vovk.ts turns them both into an async generators when they're imported from vovk-client.  import { HelloWorker } from 'vovk-client'; // ... plug in the Web Worker with &quot;use&quot; method ... for await (const number of HelloWorker.generator()) { console.log(number); // 0 ... 9 } for await (const number of HelloWorker.asyncGenerator()) { console.log(number); // 0 ... 9 }   ","version":"Next","tagName":"h2"},{"title":"Making HTTP requests inside a Worker Service Class‚Äã","type":1,"pageTitle":"Worker Service Class","url":"/docs/worker#making-http-requests-inside-a-worker-service-class","content":" Since Web Workers are run in a browser (but just in another thread) it's capable to fetch server-side data as expected.  // /src/modules/hello/HelloController.ts import { get } from 'vovk'; export class HelloController { @get.auto() static getIterations() { return { iterations: 100_000_000 }; } }   // /src/modules/hello/HelloWorker.ts import { HelloController } from 'vovk-client'; @worker() export default class HelloWorker { static private helloController = HelloController; static async heavyCalculation() { const { iterations } = await this.helloController.getIterations(); let result: number; // ... return result; } }   ","version":"Next","tagName":"h2"},{"title":"Using Worker Service Class inside another Worker Service Class‚Äã","type":1,"pageTitle":"Worker Service Class","url":"/docs/worker#using-worker-service-class-inside-another-worker-service-class","content":" Workers can use other workers. The syntax remains the same and you don't need to check for Worker variable to exist.  import { AnotherWorker } from 'vovk-client'; export default class WorkerService { private static anotherWorker = AnotherWorker; heavyCalculation() { const anotherWorkerResult = await this.anotherWorker.doSomethingHeavy(); // ... } }   ","version":"Next","tagName":"h2"},{"title":"Forking the Worker‚Äã","type":1,"pageTitle":"Worker Service Class","url":"/docs/worker#forking-the-worker","content":" To fork the worker and create as many parallel processes as needed you can use fork method instead of use.  import { HelloWorker } from 'vovk-client'; function getFork() { return HelloWorker.fork(new Worker(new URL('./path/to/HelloWorker.ts', import.meta.url))); } const HelloWorker1 = getFork(); const HelloWorker2 = getFork(); const HelloWorker3 = getFork(); const [result1, result2, result3] = await Promise.all([ HelloWorker1.heavyCalculation(), HelloWorker2.heavyCalculation(), HelloWorker3.heavyCalculation(), ]);  ","version":"Next","tagName":"h2"},{"title":"Decorators for Controller Methods","type":0,"sectionRef":"#","url":"/docs/decorators","content":"","keywords":"","version":"Next"},{"title":"Overview‚Äã","type":1,"pageTitle":"Decorators for Controller Methods","url":"/docs/decorators#overview","content":" createDecorator is a higher-order function that produces a decorator factory (a function that returns a decorator) for Controller Classes. It accepts a middleware function with the following parameters:  request, which extends NextRequest as well as VovkRequest.next, a function that should be invoked and its result returned to call subsequent decorators or the route handler.Additional arguments are passed through to the decorator factory.  The second argument of createDecorator is an optional init handler. It's called every time when decorator is initialised and it's used to populate .vovk.json with information on client-side validation explained below.  import { createDecorator, get, HttpException, HttpStatus } from 'vovk'; const myDecorator = createDecorator((req, next, a: string, b: number) =&gt; { console.log(a, b); // Outputs: &quot;foo&quot;, 1 if(isSomething) { // override route method behavior and return { hello: 'world' } from the endpoint return { hello: 'world' }; } if(isSomethingElse) { // throw HTTP error if needed throw new HttpException(HttpStatus.BAD_REQUEST, 'Something went wrong'); } return next(); }, (a: string, b: number) =&gt; { console.info('Decorator is initialised with', a, b); }); class MyController { static controllerName = 'MyController'; @get.auto() @myDecorator('foo', 1) // Passes 'foo' as 'a', and 1 as 'b' static doSomething() { // ... } }   ","version":"Next","tagName":"h2"},{"title":"Authorisation decorator example‚Äã","type":1,"pageTitle":"Decorators for Controller Methods","url":"/docs/decorators#authorisation-decorator-example","content":" There is an example code that defines authGuard decorator that does two things:  Checks if a user is authorised and returns an Unauthorised status if not.Adds currentUser to the request object.  To extend req object you can define your custom interface that extends VovkRequest. Let's imagine that Prisma ORM is used at the project.  // /src/types.ts import type { VovkRequest } from 'vovk' import type { User } from '@prisma/client'; export interface GuardedRequest&lt;BODY = undefined, QUERY extends Record&lt;string, string&gt; | undefined = undefined&gt; extends VovkRequest&lt;BODY, QUERY&gt; { currentUser: User; }   Then define the authGuard decorator itself.  // /src/decorators/authGuard.ts import { HttpException, HttpStatus, createDecorator } from 'vovk'; import type { GuardedRequest } from '../types'; const authGuard = createDecorator(async (req: GuardedRequest, next) =&gt; { // ... define userId and isAuthorised // parse access token for example if (!isAuthorised) { throw new HttpException(HttpStatus.UNAUTHORIZED, 'Unauthorized'); } const currentUser = await prisma.user.findUnique({ where: { id: userId } }); req.currentUser = currentUser; return next(); }); export default authGuard;   And finally use the decorator and define request object with your newly created GuardedRequest type.  // ... export default class UserController { // ... @get('current-user') @authGuard() static async getCurrentUser(req: GuardedRequest&lt;/* ... */&gt;) { return req.currentUser; } // ... }   ","version":"Next","tagName":"h2"},{"title":"Request Input Validation‚Äã","type":1,"pageTitle":"Decorators for Controller Methods","url":"/docs/decorators#request-input-validation","content":" Vovk.ts offers API that allows to validate request body and query string on back-end and, thanks to the metadata mechanism, performs zero-cost validation on client-side before request to the server is even made.  ","version":"Next","tagName":"h2"},{"title":"vovk-zod‚Äã","type":1,"pageTitle":"Decorators for Controller Methods","url":"/docs/decorators#vovk-zod","content":" vovk-zod is the library that implements Zod validation. It performs validation on the Controller side with ZodModel.parse, converts the Zod object to a JSON Schema that's stored at .vovk.json file, and runs validation on client before the HTTP request is made with Ajv.  // /src/modules/user/UserController.ts import { z } from 'zod'; // ... other imports ... const UpdateUserModel = z.object({ name: z.string(), email: z.email() }).strict(); const UpdateUserQueryModel = z.object({ id: z.uuid() }).strict(); export default class UserController { private static userService = UserService; @put.auto() @vovkZod(UpdateUserModel, UpdateUserQueryModel) static updateUser( req: VovkRequest&lt;z.infer&lt;typeof UpdateUserModel&gt;, z.infer&lt;typeof UpdateUserQueryModel&gt;&gt; ) { const { name, email } = await req.json(); const id = req.nextUrl.searchParams.get('id'); return this.userService.updateUser(id, { name, email }); } }   ","version":"Next","tagName":"h3"},{"title":"Creating a custom validation library‚Äã","type":1,"pageTitle":"Decorators for Controller Methods","url":"/docs/decorators#creating-a-custom-validation-library","content":" You can create a decorator that, first of all, validates request on the server-side and optionally populates controller metadata with validation information that is going to be used by the client.  The simplest example of the validation would be equality validation. It does nothing than checking if received query and body are equal to some definite object but has no practical use outside of this documentation.  At the example below validateEquality decorator is created with createDecorator that accepts 2 arguments: server validation function and init function that populates clientValidators object to define how validation information should be stored at .vovk.json file.  // /src/decorators/validateEquality.ts import { isEqual } from 'lodash'; import { HttpException, HttpStatus, createDecorator, type VovkRequest, type VovkClientOptions } from 'vovk'; type BodyValidate = Record&lt;string, unknown&gt; | null; type QueryValidate = Record&lt;string, string&gt; | null; const validateEquality = createDecorator( async (req: VovkRequest&lt;unknown&gt;, next, bodyValidate?: BodyValidate, queryValidate?: QueryValidate) =&gt; { if (bodyValidate) { const body = await req.json(); // override req.json to make it to be called again by controller code req.json = () =&gt; Promise.resolve(body); if (!isEqual(body, bodyValidate)) { throw new HttpException(HttpStatus.BAD_REQUEST, 'Server exception. Invalid body'); } } if (queryValidate) { const query = Object.fromEntries(req.nextUrl.searchParams.entries()); if (!isEqual(query, queryValidate)) { throw new HttpException(HttpStatus.BAD_REQUEST, 'Server exception. Invalid query'); } } return next(); }, (bodyValidate?: BodyValidate, queryValidate?: QueryValidate) =&gt; ({ clientValidators: { body: bodyValidate, query: queryValidate, }, }) ); export default validateEquality;   Then create a file that defines client-side validation function as default export.  // /src/decorators/validateEqualityOnClient.ts import { type VovkClientOptions, HttpException, HttpStatus } from 'vovk'; import { isEqual } from 'lodash'; // /src/decorators/validateEqualityOnClient.ts const validateEqualityOnClient: VovkClientOptions['validateOnClient'] = (input, validators) =&gt; { if (validators.body) { if (!isEqual(input.body, validators.body)) { throw new HttpException(HttpStatus.NULL, `Client exception. Invalid body`); } } if (validators.query) { if (!isEqual(input.query, validators.query)) { throw new HttpException(HttpStatus.NULL, `Client exception. Invalid query`); } } }; export default validateEqualityOnClient;   At this example validateEquality is used as a controller decorator and validateEqualityOnClient is used internally by the client. Also notice that validateEqualityOnClient throws HttpException with status 0 to simulate regular HTTP exceptions that can be caught by the client-side code.  Here is how the newly created decorator is used at controller.  // /src/modules/hello/HelloController.ts import type { VovkRequest } from 'vovk'; import validateEquality from '../decorators/validateEquality'; export default class HelloController { @post.auto() @validateEquality({ foo: 42 }, { bar: 'hello' }) static validatedRequest(req: VovkRequest&lt;{ foo: 42 }, { bar: 'hello' }&gt;) { // ... } }   In order to enable client-side validation you need to define validateOnClient option in vovk.config.js file. For more info see customization documentation.  /** @type {import('vovk').VovkConfig} */ const vovkConfig = { validateOnClient: './src/decorators/validateEqualityOnClient', } module.exports = vovkConfig;   If your validation library is published on NPM it needs to follow the same approach but use module name instead of local path to the file.  /** @type {import('vovk').VovkConfig} */ const vovkConfig = { validateOnClient: 'my-validation-library/validateEqualityOnClient', } module.exports = vovkConfig;   Resulting client code is going to look like that:  import { HelloController } from 'vovk-client'; // ... const result = await HelloController.validatedRequest({ body: { foo: 42 }, query: { bar: 'hello' }, });   validateEqualityOnClient is going to be invoked on every request before data is sent to the server.  ","version":"Next","tagName":"h3"},{"title":"Disable client validation‚Äã","type":1,"pageTitle":"Decorators for Controller Methods","url":"/docs/decorators#disable-client-validation","content":" You can set disableClientValidation option mentioned above to true to disable client validation for debugging purposes.  const result = await HelloController.validatedRequest({ body: { foo: 42 }, query: { bar: 'hello' }, disableClientValidation: true, });   If you want to disable it completely and remove it from .vovk.json file (in case if you want to hide server-side validation implementation) you can use exposeValidation option set to false at the Next.js wildcard router level.  // /src/api/[[...vovk]]/route.ts // ... export const { GET, POST, PATCH, PUT } = initVovk({ controllers, workers, exposeValidation: false // don't populate metadata file with validation information });  ","version":"Next","tagName":"h3"},{"title":"API","type":0,"sectionRef":"#","url":"/docs/api","content":"","keywords":"","version":"Next"},{"title":"Core‚Äã","type":1,"pageTitle":"API","url":"/docs/api#core","content":" ","version":"Next","tagName":"h2"},{"title":"initVovk‚Äã","type":1,"pageTitle":"API","url":"/docs/api#initvovk","content":" Creates the standard Next.js App Route handlers used by the main Optional Catch-all Segment. The function accepts the following options:  controllers: Record&lt;string, Function&gt; - the list of Controllersworkers?: Record&lt;string, Function&gt; - the list of Worker ServicesexposeValidation?: boolean - set to false if you want to hide validation logic from the client-side code.onError?: (err: Error) =&gt; void | Promise&lt;void&gt; - called on Controller exceptions, can be used to log errors by a third-party service  // /src/app/api/[[...vovk]]/route.ts import { initVovk } from 'vovk'; import HelloController from '../../../modules/hello/HelloController'; import UserController from '../../../modules/user/UserController'; import HelloWorker from '../../../modules/hello/HelloWorker'; import UserWorker from '../../../modules/user/UserWorker'; const controllers = { HelloController, UserController }; const workers = { HelloWorker, UserWorker }; export type Controllers = typeof controllers; export type Workers = typeof workers; export const { GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS } = initVovk({ controllers, workers, exposeValidation: false, onError(e) { console.log('Error', e); } });   ","version":"Next","tagName":"h3"},{"title":"createDecorator‚Äã","type":1,"pageTitle":"API","url":"/docs/api#createdecorator","content":" Defines a custom decorator to extend default behavoir of API endpoints. Accepts 2 arguments: middleware function and init function. The first one defines what the decorator is going to do, the second one is called once per initialisation and intended to pass extra data to the metadata file (for now it's client validation, if exposed).  The middleware accepts at least 2 arguments: VovkRequest, next function that needs to be called and its awaited result needs to be returned after you perform required actions and ...rest - the arguments that are going to be used by the created decorator fabric.  import { createDecorator, get, HttpException, HttpStatus } from 'vovk'; const myDecorator = createDecorator((req, next, a: string, b: number) =&gt; { console.log(a, b); // Outputs: &quot;foo&quot;, 1 if(isSomething) { // override route method behavior and return { hello: 'world' } from the endpoint return { hello: 'world' }; } if(isSomethingElse) { // throw HTTP error if needed throw new HttpException(HttpStatus.BAD_REQUEST, 'Something went wrong'); } return next(); }, (a: string, b: number) =&gt; { console.info('Decorator is initialised with', a, b); }); class MyController { static controllerName = 'MyController'; @get.auto() @myDecorator('foo', 1) // Passes 'foo' as 'a', and 1 as 'b' static getSomething() { // ... } }   ","version":"Next","tagName":"h3"},{"title":"Controller Decorators‚Äã","type":1,"pageTitle":"API","url":"/docs/api#controller-decorators","content":" ","version":"Next","tagName":"h2"},{"title":"@prefix decorator‚Äã","type":1,"pageTitle":"API","url":"/docs/api#prefix-decorator","content":" @prefix(p: string) decorator used to prepend a sub-path to the endpoint. It's usage is optional.  ","version":"Next","tagName":"h3"},{"title":"@get, @post, @put, @patch, @del, @head, @options‚Äã","type":1,"pageTitle":"API","url":"/docs/api#get-post-put-patch-del-head-options","content":" @HTTP_METHOD(p: string, opts?: { cors?: boolean, headers?: Record&lt;string, string&gt; }) decorator define an HTTP method and an endpoint that's handled by the Controller method.  ","version":"Next","tagName":"h3"},{"title":"@get.auto, @post.auto, @put.auto...‚Äã","type":1,"pageTitle":"API","url":"/docs/api#getauto-postauto-putauto","content":" @HTTP_METHOD.auto(opts?: { cors?: boolean, headers?: Record&lt;string, string&gt; }) define HTTP method and generate endpoint string automatically from controller and method name.  import { prefix, get, post, put, patch, del, head, options } from 'vovk'; @prefix('hello') export default class HelloController { @get('world', { cors: true }) static getHelloWorld() { return { hello: 'world' }; } @post.auto({ headers: { 'x-hello': 'world' }}) static postData(/* req: VovkRequest */) { return { success: true }; } }   ","version":"Next","tagName":"h3"},{"title":"worker decorator‚Äã","type":1,"pageTitle":"API","url":"/docs/api#worker-decorator","content":" Defines required onmessage handler for a Worker Service Class.  // /src/modules/hello/HelloWorkerService.ts import { worker } from 'vovk'; @worker() export default class HelloWorkerService { static heavyCalculation() { // ... } }   ","version":"Next","tagName":"h2"},{"title":"Enums‚Äã","type":1,"pageTitle":"API","url":"/docs/api#enums","content":" import { HttpMethod, HttpStatus, HttpException } from 'vovk';   HttpMethod enum‚Äã  Can be used with your code to create a custom fetcher.  export enum HttpMethod { GET = 'GET', POST = 'POST', PUT = 'PUT', PATCH = 'PATCH', DELETE = 'DELETE', HEAD = 'HEAD', OPTIONS = 'OPTIONS', }   HttpStatus enum‚Äã  Used to throw and catch errors thrown by the server. Notice NULL member. It can be used to simulate HTTP errors on client validation errors (this approach is used at vovk-zod).  export enum HttpStatus { NULL = 0, CONTINUE = 100, SWITCHING_PROTOCOLS = 101, PROCESSING = 102, EARLYHINTS = 103, OK = 200, CREATED = 201, ACCEPTED = 202, NON_AUTHORITATIVE_INFORMATION = 203, NO_CONTENT = 204, RESET_CONTENT = 205, PARTIAL_CONTENT = 206, AMBIGUOUS = 300, MOVED_PERMANENTLY = 301, FOUND = 302, SEE_OTHER = 303, NOT_MODIFIED = 304, TEMPORARY_REDIRECT = 307, PERMANENT_REDIRECT = 308, BAD_REQUEST = 400, UNAUTHORIZED = 401, PAYMENT_REQUIRED = 402, FORBIDDEN = 403, NOT_FOUND = 404, METHOD_NOT_ALLOWED = 405, NOT_ACCEPTABLE = 406, PROXY_AUTHENTICATION_REQUIRED = 407, REQUEST_TIMEOUT = 408, CONFLICT = 409, GONE = 410, LENGTH_REQUIRED = 411, PRECONDITION_FAILED = 412, PAYLOAD_TOO_LARGE = 413, URI_TOO_LONG = 414, UNSUPPORTED_MEDIA_TYPE = 415, REQUESTED_RANGE_NOT_SATISFIABLE = 416, EXPECTATION_FAILED = 417, I_AM_A_TEAPOT = 418, MISDIRECTED = 421, UNPROCESSABLE_ENTITY = 422, FAILED_DEPENDENCY = 424, PRECONDITION_REQUIRED = 428, TOO_MANY_REQUESTS = 429, INTERNAL_SERVER_ERROR = 500, NOT_IMPLEMENTED = 501, BAD_GATEWAY = 502, SERVICE_UNAVAILABLE = 503, GATEWAY_TIMEOUT = 504, HTTP_VERSION_NOT_SUPPORTED = 505, }   ","version":"Next","tagName":"h3"},{"title":"Classes‚Äã","type":1,"pageTitle":"API","url":"/docs/api#classes","content":" ","version":"Next","tagName":"h2"},{"title":"HttpException class‚Äã","type":1,"pageTitle":"API","url":"/docs/api#httpexception-class","content":" Used to throw HTTP errors on server-side and re-throw, simulate and handle HTTP errors on client-side. The instance provides 2 properties: statusCode and message.  Server-side:  // /src/modules/hello/HelloController.tsx // ... export default class HelloController { @get() static getHello() { if(/* ... */) { throw new HttpException(HttpStatus.BAD_REQUEST, 'Something went wrong'); } } }   Client-side:  // /src/modules/hello/HelloState.ts import { HelloController } from 'vovk-client'; export async function getHello() { try { return await HelloController.getHello(); } catch (e) { console.log(e instanceof HttpException); const err = e as HttpException; console.log(err.statusCode, err.message); } }   ","version":"Next","tagName":"h3"},{"title":"StreamResponse‚Äã","type":1,"pageTitle":"API","url":"/docs/api#streamresponse","content":" StreamResponse&lt;T&gt;(init?: ResponseInit) class can be used as an alternative to generators to implement response streaming. Instances of this class provide the following methods:  send(data: T) - sends portion of dataclose() - close the connectionthrow(error: any) - throws an error on client-side and closes the connection  import { prefix, get, StreamResponse, type VovkRequest } from 'vovk'; type Token = { message: string }; @prefix('stream') export default class StreamController { @get('tokens') static async streamTokens() { const resp = new StreamResponse&lt;Token&gt;(); void (async () =&gt; { const tokens: Token[] = [ { message: 'Hello,' }, { message: ' World' }, { message: '!' }, ]; for (const token of tokens) { await new Promise((resolve) =&gt; setTimeout(resolve, 300)); if(somethingWentWrong) { resp.throw(new Error('Somethiing went wrong')); } resp.send(token); } resp.close(); }); return resp; } }   The class also provides static property defaultHeaders that contains the standard headers for the keep-alive connections. Since StreamResponse accepts standard ResponseInit as options argument you can override default headers and optionally use StreamResponse.defaultHeaders.  const resp = new StreamResponse&lt;Token&gt;({ headers: { ...StreamResponse.defaultHeaders, 'x-hello': 'world', } });   ","version":"Next","tagName":"h3"},{"title":"Core types‚Äã","type":1,"pageTitle":"API","url":"/docs/api#core-types","content":" ","version":"Next","tagName":"h2"},{"title":"VovkClientFetcher and VovkDefaultFetcherOptions types‚Äã","type":1,"pageTitle":"API","url":"/docs/api#vovkclientfetcher-and-vovkdefaultfetcheroptions-types","content":" Used to redefine the default fetcher. See customization docs.  ","version":"Next","tagName":"h3"},{"title":"VovkConfig type‚Äã","type":1,"pageTitle":"API","url":"/docs/api#vovkconfig-type","content":" Defines config types.  // /vovk.config.js /** @type {import('vovk').VovkConfig} */ const vovkConfig = { // ... } module.exports = vovkConfig;   For more info check customization docs.  ","version":"Next","tagName":"h3"},{"title":"VovkEnv type‚Äã","type":1,"pageTitle":"API","url":"/docs/api#vovkenv-type","content":" Defines Vovk.ts env variable types.  For more info check customization docs.  ","version":"Next","tagName":"h3"},{"title":"VovkMetadata type‚Äã","type":1,"pageTitle":"API","url":"/docs/api#vovkmetadata-type","content":" Defines format for .vovk.json  ","version":"Next","tagName":"h3"},{"title":"VovkErrorResponse type‚Äã","type":1,"pageTitle":"API","url":"/docs/api#vovkerrorresponse-type","content":" Original shape of an object returned from the server when an error is thrown.  ","version":"Next","tagName":"h3"},{"title":"Controller Types‚Äã","type":1,"pageTitle":"API","url":"/docs/api#controller-types","content":" ","version":"Next","tagName":"h2"},{"title":"VovkRequest type‚Äã","type":1,"pageTitle":"API","url":"/docs/api#vovkrequest-type","content":" The type is used to define types for req.json and req.nextUrl.searchParams.get and allow to infer types in other environments.  // /src/modules/hello/HelloController.ts import { get, type VovkRequest } from 'vovk'; export class HelloController { @get(':someParam') static doSomething( req: VovkRequest&lt;{ body: true }, { q: string }&gt;, { someParam }: { someParam: string } ) { const body = await req.body(); // { body: true } const q = req.nextUrl.searchParams.get('q'); // string const nope = req.nextUrl.searchParams.get('nope'); // never // ... return { success: true }; } }   ","version":"Next","tagName":"h3"},{"title":"VovkBody type‚Äã","type":1,"pageTitle":"API","url":"/docs/api#vovkbody-type","content":" Extracts request body type from a controller method.  ","version":"Next","tagName":"h3"},{"title":"VovkQuery type‚Äã","type":1,"pageTitle":"API","url":"/docs/api#vovkquery-type","content":" Extracts query (search params) type from a controller method.  ","version":"Next","tagName":"h3"},{"title":"VovkParams type‚Äã","type":1,"pageTitle":"API","url":"/docs/api#vovkparams-type","content":" Extracts params type from a controller method.  ","version":"Next","tagName":"h3"},{"title":"VovkReturnType type‚Äã","type":1,"pageTitle":"API","url":"/docs/api#vovkreturntype-type","content":" Extracts return type from a controller method and unwraps the promise.  ","version":"Next","tagName":"h3"},{"title":"VovkYieldtype type‚Äã","type":1,"pageTitle":"API","url":"/docs/api#vovkyieldtype-type","content":" Extracts yield type from a controller method implemented as a generator.  // /src/modules/hello/HelloState.ts import { get, type VovkBody, type VovkQuery, type VovkParams, type VovkReturnType, type VovkYieldtype } from 'vovk'; export class HelloController { @get(':someParam') static doSomething(/* ... */) { // ... } static *generator(/* ... */) } type DoSomethingBody = VovkBody&lt;typeof HelloController.doSomething&gt;; type DoSomethingQuery = VovkQuery&lt;typeof HelloController.doSomething&gt;; type DoSomethingParams = VovkParams&lt;typeof HelloController.doSomething&gt;; type DoSomethingReturnType = VovkReturnType&lt;typeof HelloController.doSomething&gt;; type GeneratorYieldtype = VovkYieldType&lt;typeof HelloController.generator&gt;;   ","version":"Next","tagName":"h3"},{"title":"Types for the Client‚Äã","type":1,"pageTitle":"API","url":"/docs/api#types-for-the-client","content":" ","version":"Next","tagName":"h2"},{"title":"VovkClientBody type‚Äã","type":1,"pageTitle":"API","url":"/docs/api#vovkclientbody-type","content":" Extracts request body type from a clientized controller method.  ","version":"Next","tagName":"h3"},{"title":"VovkClientQuery type‚Äã","type":1,"pageTitle":"API","url":"/docs/api#vovkclientquery-type","content":" Extracts query (search params) type from a clientized controller method.  ","version":"Next","tagName":"h3"},{"title":"VovkClientParams type‚Äã","type":1,"pageTitle":"API","url":"/docs/api#vovkclientparams-type","content":" Extracts params type from a clientized controller method.  ","version":"Next","tagName":"h3"},{"title":"VovkClientReturnType type‚Äã","type":1,"pageTitle":"API","url":"/docs/api#vovkclientreturntype-type","content":" Extracts return type from a clientized controller method and unwraps the promise.  ","version":"Next","tagName":"h3"},{"title":"VovkClientYieldType type‚Äã","type":1,"pageTitle":"API","url":"/docs/api#vovkclientyieldtype-type","content":" Extracts yield type from a clientized generator controller method.  import { HelloController } from 'vovk-client'; type DoSomethingBody = VovkClientBody&lt;typeof HelloController.doSomething&gt;; type DoSomethingQuery = VovkClientQuery&lt;typeof HelloController.doSomething&gt;; type DoSomethingParams = VovkClientParams&lt;typeof HelloController.doSomething&gt;; type DoSomethingReturnType = VovkClientReturnType&lt;typeof HelloController.doSomething&gt;; type GeneratorYieldtype = VovkClientYieldType&lt;typeof HelloController.generator&gt;;   ","version":"Next","tagName":"h3"},{"title":"VovkClientOptions type‚Äã","type":1,"pageTitle":"API","url":"/docs/api#vovkclientoptions-type","content":" Type that used internally and exposed to customize the client. See decorators documentation.  ","version":"Next","tagName":"h3"},{"title":"Misc‚Äã","type":1,"pageTitle":"API","url":"/docs/api#misc","content":" ","version":"Next","tagName":"h2"},{"title":"generateStaticAPI‚Äã","type":1,"pageTitle":"API","url":"/docs/api#generatestaticapi","content":" generateStaticAPI(controllers: Record&lt;string, Function&gt;, slug?: string) is used to generate static endpoints with generateStaticParams at build time instead of on-demand at request time. It can be used in a Static Export mode with the output: 'export' Next.js config setting:  // next.config.js /** @type {import('next').NextConfig} */ const nextConfig = { output: 'export', }; module.exports = nextConfig;   To utilise this feature return generateStaticAPI results from generateStaticParams function.  // /src/app/api/[[...vovk]]/route.ts // ... export type Controllers = typeof controllers; export type Workers = typeof workers; export function generateStaticParams() { return generateStaticAPI(controllers); } export const { GET } = initVovk({ controllers, workers });   In order to make it work on a static website hosting like Github Pages, you may need to define .json extension in your endpoint definition to make it return proper HTTP headers.  import { get, prefix } from 'vovk'; @prefix('hello') export default class HelloController { @get('greeting.json') static async getHello() { return { greeting: 'Hello world!' }; } }   As result you're going to get an endpoint that looks like that: https://vovk.dev/api/hello/greeting.json. vovk.dev website is served from Github Pages and uses this endpoint for one of the examples.  In case if you use custom slug (e.g. /src/app/api/[[...custom]]/route.ts) instead of vovk you can provide it as second argument.  export function generateStaticParams() { return generateStaticAPI(controllers, 'custom'); }  ","version":"Next","tagName":"h3"},{"title":"Controller Class","type":0,"sectionRef":"#","url":"/docs/controller","content":"","keywords":"","version":"Next"},{"title":"Controller definition‚Äã","type":1,"pageTitle":"Controller Class","url":"/docs/controller#controller-definition","content":" Controller is a static class that handles incoming HTTP requests. The methods of this class that are decorated with HTTP decorator accept 2 arguments: NextRequest that is not modified in any way by Vovk.ts itself and parameters that are defined by the decorator path.  import type { NextRequest } from 'next'; import { prefix, put } from 'vovk'; @prefix('users') export default class UserController { // Example request: PUT /api/users/69?role=moderator @put(':id') static async updateUser(req: NextRequest, { id }: { id: string }) { const data = await req.json(); // any const userRole = req.nextUrl.searchParams.get('role'); // string | null // ... return updatedUser; } }   At the example aboce data is casted as any and userRole is casted as string | null. To fix the body and query types Vovk.ts provides a new type VovkRequest&lt;BODY?, QUERY?&gt; that is extended from NextRequest where the first generic argument represents the type of value returned from req.json but also allows to define values returned from req.nextUrl.searchParams.get. VovkRequest also plays a crucial role in type inference when vovk-client is used.  As its mentioned before, req object is an original NextRequest object that provided by Next.js as is without changing it, but other libraries (like vovk-zod) as well as your custom code can modify this object when needed (for example to add currentUser property defined by your auth guard decorator).  To add the required body and query types just replace NextRequest by VovkRequest. Let's modify the abstract example above.  // /src/modules/user/UserController.ts import { prefix, put, type VovkRequest } from 'vovk'; import type { User } from '../../types'; @prefix('users') export default class UserController { // Example request: PUT /api/users/69?role=moderator @put(':id') static async updateUser( req: VovkRequest&lt;Partial&lt;User&gt;, 'user' | 'moderator' | 'admin'&gt;, { id }: { id: string } ) { const data = await req.json(); // Partial&lt;User&gt; const userRole = req.nextUrl.searchParams.get('role'); // 'user' | 'moderator' | 'admin' // ... return updatedUser; } }   As you can see we've changed nothing more than the type of req but now data receives type of Partial&lt;User&gt; and userRole is casted as 'user' | 'moderator' | 'admin' and does not extend null anymore.  ","version":"Next","tagName":"h2"},{"title":"Client library‚Äã","type":1,"pageTitle":"Controller Class","url":"/docs/controller#client-library","content":" Once controller is defined it needs to be initialized at the wildcard route by adding it to the controllers object.  // /src/app/api/[[...vovk]]/route.ts import { initVovk } from 'vovk'; import UserController from '../../../modules/user/UserController'; const controllers = { UserController }; const workers = {}; // See Worker documentation export type Controllers = typeof controllers; export type Workers = typeof workers; export const { GET, POST, PUT, DELETE } = initVovk({ controllers, workers });   initVovk performs required actions to generate client-side library and no additional action from your side is required (but you probably would need to restart TS Server to update types if you use VSCode when a new controller is added).  The client library implements the same methods (in our case updateUser) but changes the method interface so you can pass required input data as options (body, query and params). vovk-client can be used in client components, server components, application state and even be distributed as a standalone package. For an illustration vovk-examples is published as a standalone NPM package to be used on vovk.dev that, by itself, is a static website powered by gh-pages.  Everything exported from vovk-client is plain old JavaScript with typings that calls the regular fetch function.  import { UserController } from 'vovk-client'; // ... const updatedUser = await UserController.updateUser({ body: { firstName, lastName }, query: { role: 'admin' }, params: { id: '69' }, }); // same as fetch('/api/users/69?role=admin', { method: 'PUT', body: JSON.stringify({ firstName, lastName }), });   It's worthy to mention that client library can be customised in order to follow custom logic required by the application.   await UserController.updateUser({ // ... successMessage: 'Successfully created the user', someOtherCustomFlag: true, });   ","version":"Next","tagName":"h2"},{"title":"Return type‚Äã","type":1,"pageTitle":"Controller Class","url":"/docs/controller#return-type","content":" ","version":"Next","tagName":"h2"},{"title":"Custom object‚Äã","type":1,"pageTitle":"Controller Class","url":"/docs/controller#custom-object","content":" The decorated static methods of controllers can return several kinds of objects. The most common is a custom object. Let's say your controller method returns Prisma ORM invocation.  // ... static async updateUser(/* ... */) { // ... const updatedUser = await prisma.user.update({ where: { id }, data, }); return updatedUser; } // ...   At this case the returned value of client method UserController.updateUser is going to be recognised as User generated at @prisma/client.  ","version":"Next","tagName":"h3"},{"title":"Response object‚Äã","type":1,"pageTitle":"Controller Class","url":"/docs/controller#response-object","content":" HTTP handlers can also return regular Response object, for example NextResponse.  // ... static async updateUser(/* ... */) { // ... return NextResponse.json(updatedUser, { status: 200 }); } // ...   At this case client library wouldn't be able to properly recognise type of returned value but you can override the type manually by using generic argument that overrides the return type without need to convert it to unknown first.  import { UserController } from 'vovk-client'; import { User } from '../../types'; // ... const updatedUser = await UserController.updateUser&lt;User&gt;(/* ... */);   ","version":"Next","tagName":"h3"},{"title":"Async iterable‚Äã","type":1,"pageTitle":"Controller Class","url":"/docs/controller#async-iterable","content":" // ... static async *updateUser(/* ... */) { // ... yield* iterable; } // ...   If iterable is returned, the client library is going to cast the method as async generator to implement response streaming. It's explained in more details below.  ","version":"Next","tagName":"h3"},{"title":"Auto-generated endpoints‚Äã","type":1,"pageTitle":"Controller Class","url":"/docs/controller#auto-generated-endpoints","content":" All HTTP decorators provide .auto method that generates endpoint name automatically from the method name.  // /src/modules/user/UserController.ts import { prefix, put } from 'vovk'; @prefix('users') export default class UserController { // Example request: PUT /api/users/do-something @put.auto() static async doSomething(/* ... */) { // ... } }   ","version":"Next","tagName":"h2"},{"title":"Response headers‚Äã","type":1,"pageTitle":"Controller Class","url":"/docs/controller#response-headers","content":" All HTTP decorators support custom response headers provided as the second argument.  // ... export default class UserController { @put('do-something', { headers: { 'x-hello': 'world' } }) static async doSomething(/* ... */) { /* ... */ } }   To enable CORS instead of manually setting up headers you can use cors: true option.  // ... export default class UserController { @put('do-something', { cors: true }) static async doSomething(/* ... */) { /* ... */ } }   For auto-generated endpoints cors and headers are defined as the only argument.  // ... export default class UserController { @put.auto({ cors: true, headers: { 'x-hello': 'world' } }) static async doSomething(/* ... */) { /* ... */ } }   ","version":"Next","tagName":"h2"},{"title":"Errors: HttpException class and HttpStatus enum‚Äã","type":1,"pageTitle":"Controller Class","url":"/docs/controller#errors-httpexception-class-and-httpstatus-enum","content":" You can gracefully throw HTTP exceptions similarly to NestJS. HttpException class accepts 2 arguments. The first one is an HTTP code that can be retrieved from HttpStatus, the other one is an error text.  import { HttpException, HttpStatus } from 'vovk'; // ... static async updateUser(/* ... */) { // ... throw new HttpException(HttpStatus.BAD_REQUEST, 'Something went wrong'); }   The errors are re-thrown at the client library with the same interface.  import { UserController } from 'vovk-client'; import { HttpException } from 'vovk'; // ... try { const updatedUser = await UserController.updateUser(/* ... */); } catch(e) { console.log(e instanceof HttpException); // true const err = e as HttpException; console.log(err.message, err.statusCode); }   Regular errors such as Error are equivalent to HttpException with code 500.  import { HttpException, HttpStatus } from 'vovk'; // ... static async updateUser(/* ... */) { // ... throw new Error('Something went wrong'); // 500 }   You can also throw custom objects that are going to be re-thrown on the client-side as is.  throw { hello: 'World' };   ","version":"Next","tagName":"h2"},{"title":"Service Class‚Äã","type":1,"pageTitle":"Controller Class","url":"/docs/controller#service-class","content":" In order to make the code cleaner it's recommended to move most of the logic to Back-end Services. Back-End Service is a static class that serves as a library that performs database and third-party API calls outside of Controller Classes.  Let's say you have the following Controller Class:  // /src/modules/user/UserController.ts import { prefix, put, type VovkRequest } from 'vovk'; import type { User } from '../../types'; @prefix('users') export default class UserController { @put(':id') static async updateUser(req: VovkRequest&lt;Partial&lt;User&gt;&gt;, { id }: { id: string }) { const data = await req.json(); const updatedUser = await prisma.user.update({ where: { id }, data, }); return updatedUser; } }   Currently it looks fine since it doesn't contain a lot of logic. But as your app is getting more complex you're going to get more handlers with more code. At this case it's recommended to move part of the logic to Back-End Service Class making controllers to be responsible for input extraction, validation and authorisation, but not for DB or API calls.  Let's refactor the code above by introducing UserService. For this example it's going to be small but I hope that illustrates the idea clearly.  // /src/modules/user/UserService.ts // ... import types and libraries ... export default class UserService { static updateUser(id: string, data: Partial&lt;User&gt;) { return prisma.user.update({ where: { id }, data, }); } }   As you can see, UserService does not use decorators and used as a library to perform side-effects.  The newly created service is injected into the controller with private static prefix. You can use UserService class directly to call its methods but this way of dependency injection is more descriptive.  // /src/modules/user/UserController.ts import { prefix, put, type VovkRequest } from 'vovk'; import UserService from './UserService' @prefix('users') export default class UserController { private static userService = UserService; @put(':id') static async updateUser(req: VovkRequest&lt;Partial&lt;User&gt;&gt;, { id }: { id: string }) { const data = await req.json(); return this.userService.updateUser(id, data); } }   Back-End Service Classes can inject other Back-End Services (as well as so-called Isomorphic Service Classes explained in separate article of this documentation).  // /src/modules/user/UserService.ts import PostService from '../post/PostService'; import CommentService from '../comment/CommentService'; // ... other imports ... export default class UserService { private static postService = PostService; private static commentService = CommentService; static async updateUser(id: string, data: Partial&lt;User&gt;) { const latestPost = this.postService.findLatestUserPost(id); const latestPostComments = this.commentService.findPostComments(latestPost.id); // ... } }   In case if two services are dependent on each other, in order to avoid errors, you can apply a workaround that involves accessor definition. For example if UserService is using PostService and vice versa, the code of the services might look like that:  // /src/modules/user/UserService.ts import PostService from '../post/PostService'; // ... other imports ... export default class UserService { private static get postService() { return PostService; }; static async updateUser(id: string, data: Partial&lt;User&gt;) { const latestPost = this.postService.findLatestUserPost(id); // ... } static async doSomething() { // ... } }   // /src/modules/post/PostService.ts import UserService from '../user/UserService'; // ... other imports ... export default class PostService { private static get userService() { return UserService; }; static async doSometingWithUser(id: string, data: Partial&lt;User&gt;) { await this.userService.doSomething(); // ... } static async findLatestUserPost(id: string) { // ... } }   ","version":"Next","tagName":"h2"},{"title":"Streaming‚Äã","type":1,"pageTitle":"Controller Class","url":"/docs/controller#streaming","content":" Vovk.ts provides two ways to implement response streaming requred for applications that utilise the AI completions.  ","version":"Next","tagName":"h2"},{"title":"Async iterators‚Äã","type":1,"pageTitle":"Controller Class","url":"/docs/controller#async-iterators","content":" Controller methods can implement generators that use * syntax and utilise yield keyword instead of regular return.  // /src/modules/stream/StreamController.ts import { get, prefix } from 'vovk'; type Token = { message: string }; @prefix('stream') export default class StreamController { @get('tokens') static async *streamTokens() { const tokens: Token[] = [ { message: 'Hello,' }, { message: ' World' }, { message: '!' }, ]; for (const token of tokens) { await new Promise((resolve) =&gt; setTimeout(resolve, 300)); yield token; } } }   In order to refactor this code and utilise Back-end Service you can move the streaming logic to StreamService static class.  // /src/modules/stream/StreamService.ts type Token = { message: string }; export default class StreamService { static async *streamTokens() { const tokens: Token[] = [ { message: 'Hello,' }, { message: ' World' }, { message: '!' }, ]; for (const token of tokens) { await new Promise((resolve) =&gt; setTimeout(resolve, 300)); yield token; } } }   At the controller use yield* syntax to delegate iterable returned from StreamService.streamTokens.  import { get, prefix } from 'vovk'; import StreamService from './StreamService'; @prefix('stream') export default class StreamController { private static streamService = StreamService; @get('tokens') static async *streamTokens() { yield* this.streamService.streamTokens(); } }   ","version":"Next","tagName":"h3"},{"title":"StreamResponse‚Äã","type":1,"pageTitle":"Controller Class","url":"/docs/controller#streamresponse","content":" In some cases it's too hard to use generators to implement response streaming. Vovk.ts introduces StreamResponse class inherited from Response class that uses TransformStream#readable as body and adds required HTTP headers. It's a lower-level API that is used behind the scenes to implement generator logic explained above. StreamResponse is useful when your service method is implemented a regular function that accepts StreamResponse instance as a pointer to send messages manually.  There is what the streaming service might look like:  // /src/modules/stream/StreamService.ts import type { StreamResponse } from 'vovk'; export type Token = { message: string }; export default class StreamService { static async streamTokens(resp: StreamResponse&lt;Token&gt;) { const tokens: Token[] = [ { message: 'Hello,' }, { message: ' World' }, { message: '!' }, ]; for (const token of tokens) { await new Promise((resolve) =&gt; setTimeout(resolve, 300)); resp.send(token); } resp.close(); } }   As you can see tokens are sent using StreamResponse#send method and, when the stream is completed, it needs to be closed with StreamResponse#close.  The Controller Class returns an instance of StreamResponse and the streaming is performed a floating Promise above the return statement.  import { prefix, get, StreamResponse, type VovkRequest } from 'vovk'; import StreamService, { type Token } from './StreamService'; @prefix('stream') export default class StreamController { private static streamService = StreamService; @get('tokens') static async streamTokens() { const resp = new StreamResponse&lt;Token&gt;(); void this.streamService.streamTokens(resp); return resp; } }   StreamResponse class also provides throw methods that safely closes the stream and makes the client to re-throw the received error.  await resp.close(); await resp.throw(new Error('Stream error'));   ","version":"Next","tagName":"h3"},{"title":"Handling Stream Responses on the Client‚Äã","type":1,"pageTitle":"Controller Class","url":"/docs/controller#handling-stream-responses-on-the-client","content":" Both ways of response streaming generate client method that returns a disposable async generator.  import { StreamController } from 'vovk-client'; { using stream = await StreamController.streamTokens(); for await (const token of stream) { console.log(token); } }   using keyword (that you can freely replace by let or const) indicates that when code block is reached the end (in case of early break or if the code block encountered an error) the stream is going to be closed by invoking stream.close() method automatically. stream.close() can also be called explicitly if needed.  To make sure that the stream is closed before moving to the next code block you can use await using syntax that disposes the stream asynchronous way.  import { StreamController } from 'vovk-client'; { await using stream = await StreamController.streamTokens(); // ... } // on this line stream is already closed   ","version":"Next","tagName":"h3"},{"title":"Validation with vovk-zod‚Äã","type":1,"pageTitle":"Controller Class","url":"/docs/controller#validation-with-vovk-zod","content":" vovk-zod is a library that implements Zod validation. It performs validation on the Controller with ZodModel.parse, converts the Zod object to a JSON Schema that's stored at the metadata file, and runs validation with Ajv on client before the request is made.  // /src/modules/user/UserController.ts import vovkZod from 'vovk-zod'; import { z } from 'zod'; import { UpdateUserModel, UpdateUserQueryModel } from '../../zod'; // ... other imports ... export default class UserController { @put(':id') @vovkZod(UpdateUserModel, UpdateUserQueryModel) static updateUser( req: VovkRequest&lt;z.infer&lt;typeof UpdateUserModel&gt;, z.infer&lt;typeof UpdateUserQueryModel&gt;&gt; ) { // ... } }   To disable client-side validation you can pass disableClientValidation: true to the client method.  import { UserController } from 'vovk-client'; // ... UserController.updateUser({ // ... disableClientValidation: true, })   disableClientValidation is mostly useful for debugging purposes to make sure that the server validation is properly functioning. In order to disable client validation completely (for example to hide validation logic from client-side so it doesn't appear in .vovk.json) you can set exposeValidation: false at initVovk function.  // /src/app/api/[[...vovk]]/route.ts // ... export const { GET, POST, PUT, DELETE } = initVovk({ controllers, workers, exposeValidation: false, });   ","version":"Next","tagName":"h2"},{"title":"Type extraction‚Äã","type":1,"pageTitle":"Controller Class","url":"/docs/controller#type-extraction","content":" vovk module provides a collection of useful types that described in more details at API documentation. It's worthy to mention the most often used types here:  import { UserController, StreamController } from 'vovk-client'; // infer body type Body = VovkClientBody&lt;typeof UserController.updateUser&gt;; // infer query type Query = VovkClientQuery&lt;typeof UserController.updateUser&gt;; // infer params type Params = VovkClientParams&lt;typeof UserController.updateUser&gt;; // infer return type type Return = VovkClientReturnType&lt;typeof UserController.updateUser&gt;; // infer yield type from stream methods type Yield = VovkClientYield&lt;typeof StreamController.streamTokens&gt;;   For example, if you want to create a custom function that makes requests to the server, you can borrow types from the client to build the arguments.  import { UserController } from 'vovk-client'; export function updateUser( id: VovkClientQuery&lt;typeof UserController.updateUser&gt;['id'], body: VovkClientBody&lt;typeof UserController.updateUser&gt;, ) { return UserController.updateUser({ body, query: { id }, }); }  ","version":"Next","tagName":"h2"}],"options":{"id":"default"}}